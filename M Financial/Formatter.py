import os
import argparse
import re
import csv
from datetime import datetime
from dateutil import parser
import shutil
import logging
import itertools


LOGGER = logging.getLogger()

def main():
    args = get_args()
    configure_logger(LOGGER, args.loglevel)
    LOGGER.info('Formatting initializing...')
    data_dir = args.data and re.sub(r'[\'"]$', '', args.data) # remove trailing single or double quotes (happens when directories are passed in as "J:\whatever\" including the trailing slash)
    save_dir = args.save and re.sub(r'[\'"]$', '', args.save) # remove trailing single or double quotes (happens when directories are passed in as "J:\whatever\" including the trailing slash)
    LOGGER.debug('parsed args')
    
    # If the save directory already exists, delete the directory and remove all contents
    # Then create the save location directory, so we start with a clean directory each time
    if os.path.exists(save_dir):
        shutil.rmtree(save_dir)
    os.mkdir(save_dir)
    LOGGER.info('Cleared previous directory')

    # Generates a list of all files in data_dir and the corresponding locations where files will be saved in save_dir
    h = getFileList(data_dir, save_dir, args.pattern)
    LOGGER.info('List of files to format and save locations generated')

    # Formats the files to be used with the BCP loading process used by the wrapper
    formatFiles(h)
    LOGGER.info('Formatting complete.')

def get_args():
    parser = argparse.ArgumentParser(description="RSDB control program")
    parser.add_argument('--data', default='', help="Directory that contains files to be formatted. Default location: None")
    parser.add_argument('--save', default='', help="Directory that contains save locations for formatted files. Default location: None")  
    parser.add_argument('--pattern', default='(?!.*superseded)^.*$') 
    parser.add_argument('--loglevel', default='INFO', help="Minimum level of log output (DEBUG/INFO/WARNING/ERROR/CRITICAL), default is 'INFO'")
    args = parser.parse_args()
    return args

def getFileList(data_dir, save_dir, regex):
    LOGGER.debug('Pulling data files to be formatted...')
    f = []
    s = []

    # Loop to grab file paths for all files in directory but ignoring files that have the regex anywhere in the path name
    for dirpath, _, filenames in os.walk(data_dir):
        data_paths = [os.path.join(dirpath, f) for f in filenames]
        fileLoc = [os.path.join(data_dir, p) for p in data_paths if re.search(regex, p)] # can't use abspath since relative to cwd
        f.extend(fileLoc)

    # Creates a new list for where files should be saved after they are formatted by updating the file list to replace the data_dir portion with save_dir location
    LOGGER.debug('Generating locations to save formatted data files...')
    for p in f:
        save=[save_dir + p.replace(data_dir,'')]
        s.extend(save)

    # zips the list together because the data location and save location should be kept as a pair
    r = list(zip(f,s))
    return r

def formatFiles(fileList):
    # File is formatted with a row number that is generated by the formatting process, which happens for every file
    # Each row number is unique for each batch run through the formatter, each time
    counter = itertools.count(1)
    for src, dst in fileList:
        # Generally files are formatted using the else procedure alone but some have unique formats which have their own functions
        if src.endswith('MAG_inforce.txt') or src.endswith('MAGinforce.txt'):
            formatMAG(src, dst, counter)
        elif src.endswith('SLD_M81pols.csv') or src.endswith('SLDM81pols.csv'):
            formatM81(src, dst, counter)
        elif src.endswith('updates.csv'):
            formatCSV(src, dst, counter)
        elif src.endswith('AddlMag.csv'):
            formatCSV(src,dst,counter)
        else:
            with open(dst, 'w') as g:
                with open(src, 'r') as f:
                    # The formatted file should not include the information headers and footers from the carrier feed
                    next(f) # read first line, discard it
                    prev_line = next(f) # get second line
                    for line, line_no in zip(f, counter): # loop is entered if there is a third
                        g.write(str(line_no).zfill(7) + prev_line) # adds the line number to each row
                        prev_line = line               

def formatMAG(src, dst, counter):
    # The feed file does not contain headers or footers that need to be removed
    # Lines that are less than 414 characters need to be filled with 0s
    with open(dst, 'w') as h:
        with open(src, 'r') as i:
            for line, line_no in zip(i, counter):
                line = line.rstrip('\n')
                line = line + ((414 - len(line)) * '0') + '\n'
                h.write(str(line_no).zfill(7) + line)   

def formatM81(src, dst, counter):
    # File is a CSV, no headers or footers to remove but need to format policy numbers to be 9 characters with leading zeros
    with open(src, 'r', newline='') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        with open(dst, 'w', newline='') as new_csv_file:
            csv_writer = csv.writer(new_csv_file,delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            for row, row_no in zip(csv_reader, counter):
                row[1] = row[1].zfill(9)
                new_row = [row_no] + row
                csv_writer.writerow(new_row)

def formatCSV(src, dst, counter):
    # File is a CSV, no other formatting needed than to add line numbers
    with open(src, 'r', newline='') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        with open(dst, 'w', newline='') as new_csv_file:
            csv_writer = csv.writer(new_csv_file,delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            for row, row_no in zip(csv_reader, counter):
                new_row = [row_no] + row
                csv_writer.writerow(new_row)

def configure_logger(logger, level):
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(filename)s - %(message)s', '%Y-%m-%d %H:%M:%S')
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    log_level = level.upper()
    logger.setLevel(log_level)

if __name__ == '__main__':
    main()